#+title: "Emacs Settings"
* Lexical Binding
#+begin_src  emacs-lisp
  (setf lexical-binding t)
#+end_src
* Hide Bars Quickly
#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (save-place-mode 1)
#+end_src
* Bootstrap Straight + Pkg Macros + All The Icons Stuff
#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (defvar all-the-icons-fonts-installed? t)
  (setf display-warning-minimum-level :error)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (setf all-the-icons-fonts-installed? nil)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  (defmacro after-load (modes &rest body)
    "Like with-eval-after-load, but also except a list of modes."
    (declare (indent 1))
    (if (not (listp modes)) (setf modes (list modes)))
    (push 'progn body)
    (dolist (i modes)
      (setf body `(with-eval-after-load ',i ,body)))
    body)

  (require 'cl-lib)
  (cl-defmacro pkg (name &optional &key require github)
    (list
     'progn
     (if github
         `(straight-use-package '(,name
                                  :type git
                                  :host github
                                  :repo ,github))
       `(straight-use-package ',name))
     (if require `(require ',name) nil)
     `',name))
#+end_src
** Hide Minor Modes
#+begin_src emacs-lisp
  (pkg diminish :require t)
#+end_src
* Fix Slow Frame Manipulation in Pgtk-Emacs
#+begin_src emacs-lisp
  (setf pgtk-wait-for-event-timeout nil)
#+end_src
* Utilities
** Concat Symbols
#+begin_src emacs-lisp
  (defun symcat (&rest symbols)
    (intern (apply #'concat (mapcar #'symbol-name symbols))))
#+end_src
** Automatically Create Files
#+begin_src emacs-lisp
  (defun ensure-file (path)
    "Create file at path if it does not exist, return path."
    (unless (file-exists-p path)
      (write-region "" nil path))
    path)
  (defun ensure-directory (path)
    "Create directory at path if it does not exist, return path."
    (unless (file-exists-p path)
      (make-directory path))
    path)
#+end_src
** File Functions
#+begin_src emacs-lisp
  (defun map-files (fun file-list)
    "Do fun with the buffer as each file in file-list."
    (dolist (file file-list)
      (let ((buf (find-file file)))
        (goto-char (point-min))						; in case file is open
        (funcall fun)
        (save-buffer)
        (kill-buffer buf))))
  (defmacro dofiles (fspec &rest body)
    "Call map-files with body across fspec where fspec is (directory regexp) or a list of such forms."
    (declare (indent 1))
    (require 'find-lisp)
    (when (stringp (car fspec)) (setf fspec (list fspec)))
    `(map-files (lambda () ,@body)
                (mapcan (lambda (e) (apply 'find-lisp-find-files e)) ',fspec)))

  (defmacro measure-time (&rest body)
    (declare (indent 0))
    "Measure the time it takes to evaluate BODY."
    (let ((time (gensym)) (result (gensym)))
      `(let* ((,time (current-time))
              (,result (progn ,@body)))
         (message "%.06f" (float-time (time-since ,time)))
         ,result)))

  (defun insert-file-name (name)
    (interactive "F")
    (insert name))
#+end_src
** Undo-Group
#+begin_src emacs-lisp
  (defmacro undo-group (&rest body)
    "Do the arguments as one undo section."
    (declare (indent 0))
    (let ((marker (gensym)))
      `(let ((,marker (prepare-change-group)))
         (unwind-protect (atomic-change-group ,@body)
           (undo-amalgamate-change-group ,marker)))))

#+end_src
** Interactive-Chain
#+begin_src emacs-lisp
  (defmacro interactive-chain (&rest args)
    "Make an interactive lambda that calls the quoted functions in args."
    (declare (indent 0))
    `(lambda () (interactive) ,@(mapcar #'cdr args)))
#+end_src
** Toggle
#+begin_src emacs-lisp
  (defmacro interactive-toggle (var-name)
    "Define a toggle function for var-name and return it."
    `(evil-define-command (symcat 'toggle- var-name)
       (setf ,var-name (not ,var-name))))
#+end_src
** Hook
#+begin_src emacs-lisp
  (defmacro hook (hook &rest body)
    "Run body after hook."
    (declare (indent 1))
    `(add-hook ,hook (lambda () ,@body)))
#+end_src
** Mode Local
#+begin_src emacs-lisp
  (pkg mode-local :require t)
#+end_src
** Act On Line
#+begin_src emacs-lisp
  (defun act-on-line (a &optional b)
    "Either (f) or ('replace f), to simply return the result of calling
  f on the current line ignoring leading space, or to replace the text
  with the result."
    (let ((f (if b b a))
          (replace (eq a 'replace)))
      (let* ((beg (line-beginning-position))
             (end (line-end-position))
             (line (buffer-substring-no-properties beg end))
             (valid (string-match (rx (* space) (group (not space)))
                                  line))
             (text-start (+ beg (or (string-match (rx (not space) (* any)) line)
                                    0)))
             (text (buffer-substring-no-properties text-start end)))
        (cond
         ((not valid) (error "No text on line."))
         (replace (kill-region text-start end)
                  (setf (point) text-start)
                  (insert (funcall f text)))
         (t (funcall f text))))))
#+end_src
** Frame Kill Buffers
#+begin_src emacs-lisp
  (defvar frame-kill-buffers nil
    "Buffer that should kill their frame when killed. Used for emacs server.")

  (add-hook 'kill-buffer-hook
            (defun delete-frame-if-frame-kill-buffer ()
              (when (memq (current-buffer) frame-kill-buffers)
                (setf frame-kill-buffers
                      (delete (current-buffer) frame-kill-buffers))
                (delete-frame))))
#+end_src
** Point Functions
#+begin_src emacs-lisp
  (defmacro with-point-at (pos &rest body)
    "Move the point to the specified position, then move it back to where it was before."
    (declare (indent 1))
    `(save-excursion (setf (point) ,pos) ,@body))
#+end_src
* Put Custom Defs in a Non-git-tracked File
#+begin_src emacs-lisp
  (setf custom-file (ensure-file (concat user-emacs-directory "custom.el")))
#+end_src
* Deal With Backups
#+begin_src emacs-lisp
  (push '("\\.\\(vcf\\|gpg\\)$" . sensitive-minor-mode) auto-mode-alist) ; don't backup keys
  (defvar backup-dir (ensure-directory (concat user-emacs-directory "backups/")))
  (setf
   backup-by-copying t ; don't clobber symlinks
   backup-directory-alist `(("." . ,backup-dir)) ; don't litter my fs tree
   delete-old-versions t
   kept-new-versions 10
   kept-old-versions 0 ; don't keep the oldest backups
   version-control t ; use versioned backups
   vc-make-backup-files t)
#+end_src
* Prefix Key Behaviour
** Translate at Any Point in a Chord
#+begin_src emacs-lisp
  (defmacro translate (key states event &rest bindings)
    "Translate (kbd key) to (kbd event) in states (quoted as in evil-define-key but not nil)."
    (declare (indent 0))
    `(progn (define-key key-translation-map
              (kbd ,key) (lambda (_)
                           (pcase evil-state
                             (,(if (symbolp (cadr states))
                                   states
                                 (cons 'or (mapcar (lambda (a) `',a) (cadr states))))
                              (kbd ,event))
                             (_ (kbd ,key)))))
            ,(if bindings `(translate ,@bindings))))
#+end_src
** Only Translate a Prefix
#+begin_src emacs-lisp
  (defun send-keys (keys)
    "Type the key sequence (kbd keys)."
    (setf prefix-arg current-prefix-arg)
    (setf unread-command-events
          (nconc (listify-key-sequence (kbd keys))
                 unread-command-events)))
  (defmacro prefix-translate (key states event &rest bindings)
    "Translate but only for keys that appear at the start of chords."
    (declare (indent 0))
    `(with-eval-after-load 'evil
       (evil-define-key ,states 'global
         (kbd ,key) (lambda () (interactive) (send-keys ,event)))
       ,@(if bindings (cddr (macroexpand-1 `(prefix-translate ,@bindings))))))
#+end_src
** Default Binds
#+begin_src emacs-lisp
  (prefix-translate
    "SPC" '(normal visual) "<leader>"
    "\\" '(normal visual) "<global-leader>"
    "M-;" 'insert "<leader>"
    "M-:" 'insert "<global-leader>")
#+end_src
** Universal Argument
#+begin_src emacs-lisp
  (define-key global-map (kbd "M-u") #'universal-argument)
  (define-key universal-argument-map (kbd "C-u") nil)
  (define-key universal-argument-map (kbd "M-u") #'universal-argument-more)
  (with-eval-after-load 'evil-maps
    (define-key evil-motion-state-map (kbd "M-u") nil))
#+end_src
* Tab Width
#+begin_src emacs-lisp
  (setq-default tab-width 4)
  (setq-default evil-shift-width tab-width)
  (setf backward-delete-char-untabify-method 'all)
  (setq-default electric-indent-inhibit t)
  (setf backward-delete-char-untabify-method 'hungry)
  (defmacro set-tab-width-in (mode tab-width)
    `(setq-mode-local ,mode evil-shift-width ,tab-width))
#+end_src
* Prettify Emacs
** Font
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Iosevka 9"))
  (set-face-attribute 'default nil :font (font-spec :family "Iosevka" :size 9.2))
#+end_src
** Ligatures
#+begin_src emacs-lisp
  (pkg ligature :require t :github "mickeynp/ligature.el")
  (ligature-set-ligatures 'prog-mode
                          '("<---" "<--" "<<-" "<-" "->" "-->" "--->" "<->" "<-->" "<--->" "<---->" "<!--" "<!---"
                            "<==" "<===" "=>" "=>>" "==>" "===>" "<=>" "<==>" "<===>" "<====>"
                            ;; "<~~" "<~" "~>" "~~>" ;; these look funny
                            ">>=" "=<<"
                            "::" ":::"
                            "==" "!=" "===" "!==" "<=" ">="
                            ":=" ":-" ":+"
                            "<|" "<|>" "|>"
                            "+:" "-:" "=:"
                            "<******>" "<*****>" "<****>" "<***>" "<**>" "<*" "<*>" "*>"
                            "++" "+++"))
  (global-ligature-mode 1)
#+end_src
** Icons
#+begin_src emacs-lisp
  (pkg all-the-icons)
  (after-load all-the-icons
   (unless all-the-icons-fonts-installed?
     (all-the-icons-install-fonts t)))
#+end_src
** Line Numbers
#+begin_src emacs-lisp
  (pkg display-line-numbers :require t)
  (global-display-line-numbers-mode 1)
  (setq-default display-line-numbers t
                display-line-numbers-widen t
                display-line-numbers-type 'relative
                display-line-numbers-width-start t
                display-line-numbers-grow-only t)
#+end_src
** Paren Highlighting
#+begin_src emacs-lisp
  (setf show-paren-delay 0)
  (show-paren-mode)
  (electric-pair-mode)
#+end_src
** Gruvbox Theme
#+begin_src emacs-lisp
  (pkg gruvbox-theme :require t)
  (load-theme 'gruvbox-dark-hard t)
#+end_src
** Start Screen (Dashboard)
#+begin_src emacs-lisp
  (pkg dashboard)
  (after-load config
    (require 'projectile)
    (require 'dashboard))
  (after-load dashboard
    (setf initial-buffer-choice (lambda () (get-buffer "*dashboard*"))
          dashboard-projects-backend 'projectile
          dashboard-items '((recents . 5) (bookmarks . 5) (agenda . 5) (projects . 5)))
    (dashboard-setup-startup-hook))
#+end_src
** Turn ^L (Line Feed) Into a Horizontal Line
#+begin_src emacs-lisp
  (pkg page-break-lines :require t)
  (diminish 'page-break-lines-mode)
  (global-page-break-lines-mode)
#+end_src
** Line Wrap
#+begin_src emacs-lisp
  (pkg visual-fill-column)
  (defun toggle-word-wrap (&optional arg)
    (interactive)
    (let ((status (or arg (if visual-line-mode 0 1))))
      (visual-line-mode status)
      (visual-fill-column-mode 0)))
  (setf visual-fill-column-mode nil)
  (defun toggle-word-wrap-at-col (&optional arg)
    (interactive)
    (let ((status (or arg (if visual-fill-column-mode 0 1))))
      (visual-line-mode status)
      (visual-fill-column-mode status)))
  (setq-default fill-column 80)
  (global-visual-line-mode)
#+end_src
* Count Keys
#+begin_src emacs-lisp
  (pkg keyfreq :require t)
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
  (setf keyfreq-excluded-commands '(self-insert-command))
#+end_src
* Vim Keys (Evil)
** Evil Requirements
Use ~undo-tree~ and ~goto-chg~ to get the related features in evil.
#+begin_src emacs-lisp
  (pkg undo-tree :require t)
  (diminish 'undo-tree-mode)
  (setf undo-tree-visualizer-timestamps t
        undo-tree-visualizer-lazy-drawing nil
        undo-tree-auto-save-history t)
  (let ((undo-dir (expand-file-name "undo" user-emacs-directory)))
    (setf undo-tree-history-directory-alist (list (cons "." undo-dir))))
  ;; this is broken, the after save hook below fixes it, but it still needs to be here
  (hook 'after-save-hook (when undo-tree-mode (undo-tree-save-history nil t)))
  (global-undo-tree-mode)

  (pkg goto-chg :require t)
#+end_src
** Make <backspace> Work Like C-g
#+begin_src emacs-lisp
  (define-key key-translation-map
    (kbd "DEL") (lambda (c) (kbd (if (eq evil-state 'insert) "DEL" "C-g"))))
#+end_src
** Evil
#+begin_src emacs-lisp
  (setf
   evil-want-keybinding nil
   evil-search-module 'evil-search
   evil-undo-system 'undo-tree
   evil-cross-lines t
   evil-ex-substitute-global t
   evil-want-C-u-scroll t
   evil-want-C-i-jump t
   evil-want-visual-char-semi-exclusive t
   evil-want-Y-yank-to-eol t
   evil-ex-search-vim-style-regexp t
   evil-ex-substitute-global t
   evil-ex-visual-char-range t ; column range for ex commands this doesn't work
   evil-symbol-word-search t	 ; more vim-like behavior
   evil-want-change-word-to-end nil ; ce and cw are now different
   shift-select-mode nil						; don't activate mark on shift-click
   )

  (pkg evil :require t)

  (evil-mode 1)
  (setf evil-emacs-state-cursor 'box
        evil-normal-state-cursor 'box
        evil-visual-state-cursor 'box
        evil-insert-state-cursor 'bar
        evil-replace-state-cursor 'hbar
        evil-operator-state-cursor 'hollow)
  (setf evil-extra-operator-eval-modes-alist
        '((lisp-mode sly-eval-region)
          (scheme-mode geiser-eval-region)
          (clojure-mode cider-eval-region)
          (ruby-mode ruby-send-region)
          (enh-ruby-mode ruby-send-region)
          (python-mode python-shell-send-region)
          (julia-mode julia-shell-run-region)))
  (evil-define-key 'normal evil-ex-search-keymap
    "j" #'next-line-or-history-element
    "k" #'previous-line-or-history-element)
  (evil-define-key 'motion 'global
    (kbd "M-e") #'evil-backward-word-end
    (kbd "M-E") #'evil-backward-WORD-end)
#+end_src
** Evil Collection
#+begin_src emacs-lisp
  (setf evil-collection-setup-minibuffer t)
  (pkg evil-collection :require t)
  (diminish 'evil-collection-unimpaired-mode)
  (setf evil-collection-mode-list (delete 'lispy evil-collection-mode-list))
  (evil-collection-init)
#+end_src
** Evil Extensions
*** Surround
Allow actions that act on surrounding delimiters: =ds=, =cs=, =ys=, etc.
#+begin_src emacs-lisp
  (pkg evil-surround :require t)
  (setq-default evil-surround-pairs-alist
                (append '((?“ . ("“" . "”"))
                          (?” . ("“ " . " ”")))
                        evil-surround-pairs-alist))
  (global-evil-surround-mode 1)
#+end_src
*** Text Objects
#+begin_src emacs-lisp
  (pkg targets :require t :github "noctuid/targets.el")
  (targets-setup t)
#+end_src
*** Swap Text Using =gx=
#+begin_src emacs-lisp
  (pkg evil-exchange :require t)
  (evil-exchange-install)
#+end_src
*** Fix =cc= in Minibuffer
  It inserts a newline if the final line after it has run is empty,
  removing completions.
  TODO report this to evil-collection, I think it comes from the
  function deleting up to a new line then inserting a new one to
  adjust.
#+begin_src emacs-lisp
  (evil-define-operator evil-change-minibuffer-fix
    (beg end type register yank-handler delete-func)
    (interactive "<R><x><y>")
    (let ((at-end (= end (point-max))))
      (evil-change beg end type register yank-handler delete-func)
      (if (and at-end (not (= (point) (point-max)))) (delete-char 1))))

  (dolist (i evil-collection-minibuffer-maps)
    (evil-define-key 'normal (eval i)
      "c" #'evil-change-minibuffer-fix
      "j" #'previous-complete-history-element
      "k" #'next-complete-history-element))
#+end_src
*** Register Previews
#+begin_src emacs-lisp
  (pkg evil-owl :require t)
  (setq evil-owl-max-string-length 500)
  (diminish 'evil-owl-mode)
  (evil-owl-mode)
#+end_src
* Misc Settings
** Variables
#+begin_src emacs-lisp
  (setf
   ;; Sentence regexes only allow double spaced sentences, stop that.
   sentence-end-double-space nil
   ;; Add more detail to describe-* functions.
   sentence-end-double-space nil
   ;; This also highlights a lot of non-error things.
   next-error-message-highlight t
   ;; Ensure documentation is loaded from autoloaded functions
   help-enable-symbol-autoload t)
#+end_src
** Right Click Menu
#+begin_src emacs-lisp
  (context-menu-mode)
#+end_src
* Global Binds
#+begin_src emacs-lisp
  (evil-define-key '(normal visual) 'global
    (kbd "<leader>;") #'execute-extended-command
    "ge" (evil-define-operator evil-eval (beg end)
           "Evaluate code."
           :move-point nil
           (let* ((ele (assoc major-mode evil-extra-operator-eval-modes-alist))
                  (f-a (cdr-safe ele))
                  (func (car-safe f-a))
                  (args (cdr-safe f-a)))
             (if (fboundp func)
                 (apply func beg end args)
               (eval-region beg end t))))
    "gE" (evil-define-operator evil-eval-elisp-replace (beg end)
           "Evaluate code then replace with result."
           :move-point nil
           (let ((result (eval (car (read-from-string (buffer-substring-no-properties beg end))))))
             (evil-delete beg end nil ?_)
             (message "%S" result)
             (insert (prin1-to-string result))))
    "gc" (evil-define-operator evil-comment (beg end)
           "Commenting code."
           (comment-or-uncomment-region beg end))
    "gC" (evil-define-operator evil-comment+yank (beg end type register)
           "Commenting code and yanking original."
           (interactive "<R><x>")
           (evil-yank beg end type register)
           (comment-or-uncomment-region beg end))
    "gs" (evil-define-operator evil-replace-with-reg (beg end type register)
           "Replace region with active register."
           (interactive "<R><x>")
           (evil-delete beg end type ?_)
           (insert (evil-get-register (or register ?\")))))

  (evil-define-key 'motion 'global
    "]]" (evil-define-motion evil-next-close-bracket (count)
           "Go to [count] next unmatched ')'."
           :type exclusive
           (forward-char)
           (evil-up-paren ?\[ ?\] (or count 1))
           (backward-char))
    "[[" (evil-define-motion evil-previous-open-bracket (count)
           "Go to [count] previous unmatched '{'."
           :type exclusive
           (evil-up-paren ?\[ ?\] (- (or count 1)))))

  (evil-define-key 'normal 'global
    (kbd "U") #'evil-redo
    (kbd "<escape>") #'evil-ex-nohighlight
    (kbd "<global-leader>s") (evil-define-command goto-scratch-buffer ()
                               (switch-to-buffer "*scratch*"))
    (kbd "<global-leader>b") #'bookmark-jump
    (kbd "<global-leader>B") #'bookmark-set
    (kbd "<global-leader>td") #'toggle-debug-on-error
    (kbd "<global-leader>tw") #'toggle-word-wrap
    (kbd "<global-leader>tW") #'toggle-word-wrap-at-col
    (kbd "<global-leader>tp") (evil-define-command toggle-profiler ()
                                (require 'profiler)
                                (if (not (profiler-running-p))
                                    (profiler-start 'cpu+mem)
                                  (profiler-stop)
                                  (profiler-report)))
    (kbd "S") (evil-define-command evil-file-substitute () (evil-ex "%s/"))
    (kbd "gB") #'ibuffer)

  (evil-define-text-object evil-whole-buffer (count &optional beg end type)
    "Whole buffer." (list (point-min) (point-max)))
  (define-key evil-outer-text-objects-map (kbd "g") #'evil-whole-buffer)
#+end_src
** Printing
#+begin_src emacs-lisp
  (defvar mode-print-formatter nil
    "A function that takes a string of text on a line and turns them into a print statement in the current mode.")

  (defun print-text-on-line ()
    "Apply mode-print-formatter to the text on the current line."
    (interactive)
    (act-on-line #'replace mode-print-formatter))

  (evil-define-key 'normal 'global
    (kbd "gp") #'print-text-on-line)
  (evil-define-key 'insert 'global
    (kbd "M-p") #'print-text-on-line)
#+end_src
** Window / Buffer
#+begin_src emacs-lisp
  (evil-define-key nil 'global
    (kbd "C-h") #'evil-window-left
    (kbd "C-j") #'evil-window-down
    (kbd "C-k") #'evil-window-up
    (kbd "C-l") #'evil-window-right
    (kbd "C-q") #'image-kill-buffer
    (kbd "C-S-q") (evil-define-command save-&-kill-buffer () (save-buffer) (kill-buffer))
    (kbd "M-RET") (evil-define-command split-right ()
                    (split-window-horizontally)
                    (evil-window-right 1))
    (kbd "M-S-RET") (evil-define-command split-left () (split-window-horizontally))
    (kbd "M-DEL") (evil-define-command split-down ()
                    (split-window-vertically)
                    (evil-window-down 1))
    (kbd "M-S-DEL") (evil-define-command split-up () (split-window-vertically)))

  (evil-define-key 'normal 'global
    (kbd "C-w RET") #'split-right
    (kbd "C-w S-RET") #'split-left
    (kbd "C-w DEL") #'split-down
    (kbd "C-w S-DEL") #'split-up)
#+end_src
* Help Mode
#+begin_src emacs-lisp
  (evil-define-key 'normal help-mode-map
    (kbd "s") #'help-view-source
    (kbd "i") #'help-goto-info
    (kbd "c") #'help-customize
    (kbd "<space>") nil
    (kbd "SPC") nil)
#+end_src
* Center The Cursor
#+begin_src emacs-lisp
  (pkg centered-cursor-mode :require t)
  (diminish 'centered-cursor-mode)
  (global-centered-cursor-mode 1)
  (push #'evil-insert-state-p ccm-inhibit-centering-when)
  (push #'lsp-ui-doc--handle-mouse-movement ccm-ignored-commands)
  (push #'abort-recursive-edit ccm-ignored-commands)
#+end_src
* Restart
#+begin_src emacs-lisp
  (pkg restart-emacs)
  (evil-define-key 'global 'normal
    (kbd "<global-leader>rr") #'restart-emacs)
#+end_src
* Languages / File-types
** Lisp
#+begin_src emacs-lisp
  (pkg lispy)
  (diminish 'lispy-mode)
  (set-tab-width-in lisp-mode 2)
  (set-tab-width-in emacs-lisp-mode 2)
  (set-tab-width-in common-lisp-mode 2)
  (set-tab-width-in clojure-mode 2)
  (set-tab-width-in scheme-mode 2)

  (pkg lispyville)
  (diminish 'lispyville-mode)
  (add-hook 'emacs-lisp-mode-hook #'lispyville-mode)
  (add-hook 'common-lisp-mode-hook #'lispyville-mode)
  (add-hook 'lisp-mode-hook #'lispyville-mode)
  (hook 'lispyville-mode-hook
    (cl-macrolet ((defto (name key)
                    `(targets-define-to ,name ',name nil object :bind t
                                        :keys ,key :hooks lispyville-mode-hook)))
      (defto lispyville-comment "c")
      (defto lispyville-atom "a")
      (defto lispyville-list "f")
      (defto lispyville-sexp "x")
      (defto lispyville-function "d")
      (defto lispyville-string "s")))
  (after-load lispyville
    (lispyville-set-key-theme '(operators
                                c-w
                                prettify
                                (atom-movement t)
                                additional-movement
                                commentary
                                slurp/barf-cp
                                (escape insert)))
    (defmacro surround-paren-insert (object at-end)
      "Surround object and instert at the given end (either start or end)."
      `(lambda () (interactive)
         (evil-start-undo-step)
         (apply 'evil-surround-region
                (append (let* ((obj (,object))
                               (start (car obj)))
                          (if (eq (char-after start) ?')
                              (cons (+ 1 start) (cdr obj))
                            obj))
                        '(?\))))
         ,@(if (eq at-end 'end)
               '((lispyville-up-list)
                 (insert " ")
                 (evil-insert 1))
             '((forward-char)
               (insert " ")
               (backward-char 1)
               (evil-insert 1)))))
                                          ; TODO make these work for visual
    (evil-define-key '(visual normal) lispyville-mode-map
      (kbd "<leader>(") #'lispy-wrap-round
      (kbd "<leader>{") #'lispy-wrap-braces
      (kbd "<leader>[") #'lispy-wrap-brackets
      (kbd "<leader>)") #'lispyville-wrap-with-round
      (kbd "<leader>}") #'lispyville-wrap-with-braces
      (kbd "<leader>]") #'lispyville-wrap-with-brackets
      (kbd "M-j") #'lispyville-drag-forward
      (kbd "M-k") #'lispyville-drag-backward
      (kbd "<leader>@") #'lispy-splice
      (kbd "<leader>w") (surround-paren-insert targets-inner-lispyville-sexp start)
      (kbd "<leader>W") (surround-paren-insert targets-inner-lispyville-sexp end)
      (kbd "<leader>i") (surround-paren-insert targets-a-lispyville-list start)
      (kbd "<leader>I") (surround-paren-insert targets-a-lispyville-list end)
      (kbd "<leader>s") #'lispy-split
      (kbd "<leader>j") #'lispy-join
      (kbd "<leader>r") #'lispy-raise-sexp
      (kbd "<leader>R") #'lispyville-raise-list
      (kbd "<leader>h") (evil-define-command lispyville-insert-at-beginnging-of-list (count)
                          (interactive "<c>")
                          (lispyville-insert-at-beginning-of-list count)
                          (insert " ")
                          (backward-char))
      (kbd "<leader>l") #'lispyville-insert-at-end-of-list
      (kbd "<leader>o") #'lispyville-open-below-list
      (kbd "<leader>O") #'lispyville-open-above-list))
#+end_src
** Common Lisp
#+begin_src emacs-lisp
  (pkg sly)
  (setf inferior-lisp-program "/usr/bin/sbcl")
  (cl-macrolet ((defmacroexpand (name fn)
                  `(evil-define-operator ,name (beg end)
                     :move-point nil
                     (with-save-point
                       (setf (point) beg)
                       (,fn)))))
    (defmacroexpand sly-evil-macroexpand-all sly-macroexpand-all)
    (defmacroexpand sly-evil-macroexpand-1 sly-macroexpand-1)
    (defmacroexpand sly-evil-macroexpand-all-inplace sly-macroexpand-all-inplace)
    (defmacroexpand sly-evil-macroexpand-1-inplace sly-macroexpand-1-inplace))
  (evil-define-key '(normal visual) sly-mode-map
    "=" (evil-define-operator evil-lisp-indent-region (beg end)
          :type line
          :move-point nil
          (lisp-indent-region beg end))
    (kbd "<leader>me") #'sly-evil-macroexpand-all
    (kbd "<leader>m1") #'sly-evil-macroexpand-1
    (kbd "<leader>Me") #'sly-evil-macroexpand-all-inplace
    (kbd "<leader>M1") #'sly-evil-macroexpand-1-inplace
    (kbd "<leader>fu") #'sly-undefine-function)
#+end_src
** Rust
#+begin_src emacs-lisp
  (pkg rustic)
  (setf lsp-rust-server 'rust-analyzer)
  (setq-mode-local rustic-mode
                   lsp-ui-sideline-show-hover nil
                   lsp-rust-analyzer-cargo-watch-command "clippy")
  (set-tab-width-in rust-mode 2)
  (setf rust-indent-offset 2)
  (custom-set-default 'rustic-indent-offset 2)
  (setq-mode-local rustic-mode mode-print-formatter
                   (lambda (text)
                     (let ((braces ""))
                       (concat "println!(\"{:#?}\", (" text "));"))))

  (pkg flycheck-rust)
  (add-hook 'rust-mode-hook 'flycheck-rust-setup)
#+end_src
** C#
#+begin_src emacs-lisp
  (pkg csharp-mode)
  (add-to-list 'auto-mode-alist '("\\.cs\\'" . csharp-mode))
  (setq-mode-local csharp-mode lsp-ui-sideline-show-hover nil)
  (setq-mode-local csharp-mode mode-print-formatter
                   (lambda (str)
                     (setf str (replace-regexp-in-string ";" "," str))
                     (concat "GD.PrintS(" str ");")))
  ;; (setf lsp-csharp-server-path "/usr/bin/omnisharp")
  (add-hook 'csharp-mode-hook 'lsp)
  (set-tab-width-in csharp-mode 4)
#+end_src
** Scheme
#+begin_src emacs-lisp
  (pkg geiser)
  (add-hook 'scheme-mode-hook #'geiser-mode)
  (add-hook 'scheme-mode-hook #'lispyville-mode)
  (add-hook 'geiser-mode-hook #'run-geiser)
  (setf geiser-mode-start-repl-p t)

  (pkg geiser-guile)
  (after-load geiser
    (require 'geiser-guile)
    (evil-define-key 'normal geiser-mode-map
      (kbd "<insert>") #'geiser-mode-switch-to-repl))
#+end_src
** Anki External Editor
#+begin_src emacs-lisp
  (defvar anki-mode-hook nil)
  (defvar anki-mode-map (make-sparse-keymap))
  (evil-define-key 'normal anki-mode-map
    (kbd "<leader>m") #'org-latex-preview)
  (targets-define-to latex-math-block "\\$(" ")\\$"
                     pair :bind t :keys "m" :hooks anki-mode-hook)
  (targets-define-to latex-MATH-block "\\$( " " )\\$"
                     pair :bind t :keys "M" :hooks anki-mode-hook)

  (defun replace-all (regex replacement)
    (replace-regexp (regexp-quote regex) replacement nil (point-min) (point-max)))

  (defun anki-mode ()
    "Major mode for editing Anki flashcards."
    (interactive)
    (kill-all-local-variables)
    (use-local-map anki-mode-map)

    (replace-all "[$]" "$(")
    (replace-all "[/$]" ")$")
    (add-hook 'before-save-hook
              (lambda () (replace-all "$(" "[$]"))
              nil t)
    (add-hook 'before-save-hook
              (lambda () (replace-all ")$" "[/$]"))
              nil t)
    (flyspell-mode)

    (setf require-final-newline nil)
    (setf evil-surround-pairs-alist
          (append '((?m . ("$(" . ")$"))
                    (?M . ("$( " . " )$")))
                  evil-surround-pairs-alist))
    (setf major-mode 'anki-mode)
    (setf mode-name "Anki")
    (run-hooks 'anki-mode-hook))
#+end_src
** Haskell
#+begin_src emacs-lisp
  (pkg haskell-mode)
  (pkg lsp-haskell)
  (after-load haskell-mode (require 'lsp-haskell))
  (add-hook 'haskell-mode-hook #'lsp)
  (setq-mode-local haskell-mode
                   lsp-ui-sideline-show-hover nil
                   electric-pair-pairs (cons '(?` . ?`) electric-pair-pairs))
  (setf lsp-haskell-formatting-provider "fourmolu")
#+end_src
** Context
#+begin_src emacs-lisp
  (defvar context-tags)
  (defvar context-start/end-tags)
  (defvar context-insert-tag--tag-hist)
  (defvar context-insert-tag--start/end-hist)
  (defun context-get-tag-pair ()
    (-if-let* ((str (completing-read "Start/End: " context-start/end-tags
                                     nil nil nil 'context-insert-tag--start/end-hist))
               ((start end) (split-string str "/"))
               (type (completing-read "Type: " context-tags
                                      nil nil nil 'context-insert-tag--tag-hist)))
        (list (concat "\\" start type) (concat "\\" end type))
      (error "Expected only one slash in pattern.")))
  (defun context-insert-tag-pair (start end)
    (interactive (context-get-tag-pair))
    "Insert start| \\n end, leave the point on the |."
    (insert start)
    (save-excursion (newline) (insert end)))
  (evil-define-operator context-wrap-tag-pair (beg end)
    "Wrap region in tag."
    :type line
    (let ((pair (context-get-tag-pair)))
      (goto-char end)
      (insert (cadr pair))
      (newline)
      (goto-char beg)
      (insert (car pair))
      (save-excursion (newline))))

  (setf context-start/end-tags '("start/stop" "b/e"))
  (setf context-tags '("paragraph" "itemize" "component" "TABLE" "TABLEhead" "TABLEbody" "TC" "TR" "TH"))

  (evil-define-key 'insert tex-mode-map
    (kbd "<leader>t") #'context-insert-tag-pair)
  (evil-define-key 'normal tex-mode-map
    (kbd "<leader>ti") #'context-insert-tag-pair)
  (evil-define-key '(normal visual) tex-mode-map
    (kbd "<leader>tw") #'context-wrap-tag-pair)

#+end_src
** Org
*** Org-mode
#+begin_src emacs-lisp
  (evil-define-key 'normal 'global
    (kbd "<global-leader>a") 'org-agenda
    (kbd "<global-leader>A") (evil-define-command visit-roam-agenda ()
                               (require 'org-roam)
                               (org-roam-node-visit (org-roam-node-from-title-or-alias "Agenda"))
                               (goto-char (point-max))))
  (diminish 'org-indent-mode)
  (hook 'org-mode-hook
    (org-indent-mode)
    (setq-local electric-pair-inhibit-predicate
                `(lambda (p) (or (char-equal p ?<)
                                 (,electric-pair-inhibit-predicate p)))))
  (setf org-todo-keywords '((sequence "TODO" "IN-PROGRESS" "DONE"))
        org-hide-emphasis-markers t
        org-pretty-entities t
        org-pretty-entities-include-sub-superscripts t
        org-startup-with-latex-preview t
        org-imenu-depth 4)

  (after-load org
    ;; Increase size of latex previews.
    (plist-put org-format-latex-options :scale 1.3)
    (custom-set-faces
     '(org-level-1 ((t (:inherit outline-1 :height 1.5))))
     '(org-level-2 ((t (:inherit outline-2 :height 1.4))))
     '(org-level-3 ((t (:inherit outline-3 :height 1.3))))
     '(org-level-4 ((t (:inherit outline-4 :height 1.2))))
     '(org-level-5 ((t (:inherit outline-5 :height 1.1)))))
    ;; Don't make text bigger after 8 levels.
    (setf org-cycle-level-faces nil))
  (setf org-fontify-done-headline nil)
#+end_src
*** Hide Org Markup
#+begin_src emacs-lisp
  (pkg org-appear)
  (add-hook 'org-mode-hook 'org-appear-mode)
  (mapc (lambda (sym) (set sym t))
        '(org-appear-autoemphasis
          org-appear-autolinks
          org-appear-autoentities
          org-appear-autokeywords
          org-appear-autosubmarkers))
#+end_src
*** Roam
#+begin_src emacs-lisp
  (pkg org-roam)
  (setf org-roam-v2-ack t
        org-roam-completion-everywhere t
        org-roam-directory (file-truename "~/org"))
  (defun org-roam-get-unlinked-node-ids ()
    "Get the IDs of nodes with no backlinks."
    (cl-set-difference (mapcar #'car (org-roam-db-query [:select id :from nodes]))
                       (mapcar #'car (org-roam-db-query [:select dest :from links]))
                       :test 'string=))
  (evil-define-key 'normal 'global
    (kbd "<global-leader>nf") #'org-roam-node-find
    (kbd "<global-leader>nu")
    (evil-define-command org-roam-unlinked-node-find (&optional other-window initial-input filter-fn)
      "Find nodes with no backlinks."
      (let ((titles (mapcar (lambda (id) (-> id org-roam-node-from-id org-roam-node-title))
                            (org-roam-get-unlinked-node-ids))))
        (org-roam-node-visit (org-roam-node-from-title-or-alias
                              (completing-read "Node: " titles filter-fn t initial-input))
                             other-window))))

  (after-load org-roam
    (cl-flet ((template-with-tags
               (key name tags)
               `(,key ,name plain "\n%?"
                      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                                         ,(concat "#+title: ${title}\n#+filetags: " tags "\n"))
                      :unnarrowed t)))
      (setf org-roam-capture-templates
            (list '("d" "default" plain "\n%?"
                    :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
                    :unnarrowed t)
                  (template-with-tags "c" "computer science A-level" ":CSAL:")
                  (template-with-tags "p" "physics A-level" ":PAL:")
                  (template-with-tags "m" "maths A-level" ":MAL:")
                  (template-with-tags "f" "further maths A-level" ":FMAL:")
                  (template-with-tags "w" "word" ":Word:"))))
    (nconc org-roam-capture-templates
           '(("t" "like the regular template but todo"))
           (mapcar (lambda (templ)
                     (setf (car templ) (concat "t" (car templ)))
                     (let (out finnish-used? i)
                       (while (setf i (pop templ))
                         (cond
                          ((eq i :if-new)
                           (push i out)
                           (setf i (pop templ))
                           (cl-symbol-macrolet ((target (caddr i)))
                             (let ((reg (rx line-start "#+filetags:"
                                            (+ space)
                                            (group (*? anychar))
                                            ":\n")))
                               (setf target
                                     (if (string-match reg target)
                                         (replace-regexp-in-string reg "#+filetags: \\1:TODO:\n" target)
                                       (concat target "#+filetags: :TODO:\n")))))
                           (push i out))
                          ((eq i :immediate-finish) (pop templ))
                          (t (push i out))))
                       (nreverse (cons t (cons :immediate-finish out)))))
                   (copy-tree org-roam-capture-templates)))

    (evil-define-key 'insert org-mode-map
      (kbd "<leader>n") #'org-roam-node-insert)
    (evil-define-key 'normal org-mode-map
      (kbd "<leader>nb") #'org-roam-buffer-toggle
      (kbd "<leader>ng") #'org-roam-graph
      (kbd "<leader>ni") #'org-roam-node-insert
      (kbd "<leader>nc") #'org-roam-capture
      (kbd "<leader>nn") #'org-id-get-create
      (kbd "<leader>nt") #'org-roam-tag-add
      (kbd "<leader>nT") #'org-roam-tag-remove
      (kbd "<leader>nd") #'org-roam-dailies-capture-today
      (kbd "<leader>na") #'org-roam-alias-add)
    (org-roam-db-autosync-mode)
    ;; If using org-roam-protocol
    ;; (require 'org-roam-protocol)
    )
#+end_src
*** Evil Integration
#+begin_src emacs-lisp
  (pkg evil-org)
  (add-hook 'org-mode-hook 'evil-org-mode)
  (after-load evil-org
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (evil-define-key 'insert org-mode-map
      (kbd "<leader>b") #'org-insert-structure-template
      (kbd "M-h") #'org-metaleft
      (kbd "M-l") #'org-metaright)
    (evil-define-key 'normal org-capture-mode-map
      (leader "k") #'org-capture-kill
      (leader "c") #'org-capture-finalize)
    (evil-define-key '(normal insert) org-mode-map
      (kbd "<leader>.") #'org-time-stamp
      (kbd "<leader>l") #'org-insert-link)
    (evil-define-key 'normal org-mode-map
      (kbd "<leader>i") #'org-display-inline-images
      (kbd "<leader>I") #'org-remove-inline-images
      (kbd "<leader>m") #'org-latex-preview
      (kbd "<leader>a") #'org-agenda-file-to-front
      (kbd "<leader>r") #'org-remove-file
      (kbd "<leader>c") #'org-ctrl-c-ctrl-c
      (kbd "<leader>l") #'org-insert-link
      (kbd "<leader>d") #'org-deadline
      (kbd "<leader>s") #'org-schedule
      (kbd "<leader>p") #'org-priority
      (kbd "<leader>RET") #'org-open-at-point
      (kbd "<leader>t") #'org-shiftright
      (kbd "<leader>T") #'org-shiftleft
      (kbd "<leader>bi") #'org-insert-structure-template
      (kbd "<leader>be") #'org-edit-src-code
      (kbd "<leader>bs") (evil-define-command evil-split-org-strucutre-template ()
                           (let ((point (point)) start-line end-line)
                             (cl-destructuring-bind ((_ end _) (start _ _)) `(,(evil-org-inner-element)
                                                                              ,(evil-org-an-element))
                               (cl-loop for (line var) in `((,start start-line) (,end end-line))
                                        do (goto-char line)
                                        do (set var (buffer-substring-no-properties
                                                     (line-beginning-position)
                                                     (line-end-position))))
                               (goto-char point)
                               (evil-insert-newline-below)
                               (insert (format "%s\n%s" end-line start-line)))))
      (kbd "<leader>bw") (evil-define-operator evil-wrap-org-structure-template (beg end)
                           "Wrap region in structure template"
                           :type line
                           (goto-char beg)
                           (set-mark end)
                           (call-interactively #'org-insert-structure-template))))
#+end_src
* Show Keyboard Shortcuts
#+begin_src emacs-lisp
  (pkg which-key :require t)
  (diminish 'which-key-mode)
  (which-key-mode)
#+end_src
* Completion
** Minibuffer
*** Completions
#+begin_src emacs-lisp
  (pkg selectrum :require t)
  (selectrum-mode)
  (evil-define-key '(insert normal) selectrum-minibuffer-map
    (kbd "M-RET") #'selectrum-submit-exact-input
    (kbd "M-TAB") #'selectrum-insert-current-candidate
    (kbd "TAB") #'selectrum-next-candidate
    (kbd "<backtab>") #'selectrum-previous-candidate)
#+end_src
*** Descriptions in Margins
#+begin_src emacs-lisp
  (pkg marginalia :require t)
  (marginalia-mode)
#+end_src
** Buffer
*** Completions
#+begin_src emacs-lisp
  (pkg company :require t)
  (diminish 'company-mode)
  (setf company-idle-delay 0
        company-minimum-prefix-length 1
        company-selection-wrap-around t)

  (add-hook 'company-mode-hook 'company-tng-mode)
  (evil-define-key 'insert company-mode-map
    (kbd "TAB") #'company-complete)
  (evil-define-key nil company-active-map
    (kbd "<tab>") (interactive-chain #'company-complete-common #'company-select-next)
    (kbd "TAB") #'company-select-next
    (kbd "<backtab>") #'company-select-previous
    (kbd "M-TAB") #'company-complete-common
    (kbd "M-q") (interactive-chain #'company-select-first #'company-select-previous)
    (kbd "<next>") #'company-next-page
    (kbd "<prior>") #'company-previous-page
    ;;Avoid conflicting keybinds
    (kbd "<return>") nil
    (kbd "RET") nil
    (kbd "M-p"))
  (global-company-mode)
#+end_src
*** Prettify
#+begin_src emacs-lisp
  (pkg company-box :require t :github "jack-faller/company-box") ; use my fix for tng-mode docstrings
  (diminish 'company-box-mode)
  (add-hook 'company-tng-mode-hook #'company-box-mode)
  (setf company-box-doc-delay 0.13
        company-box-icons-all-the-icons
        `((Unknown . ,(all-the-icons-material "find_in_page" :height 0.8 :face 'all-the-icons-purple))
          (Text . ,(all-the-icons-material "text_fields" :height 0.8 :face 'all-the-icons-green))
          (Method . ,(all-the-icons-material "functions" :height 0.8 :face 'all-the-icons-red))
          (Function . ,(all-the-icons-material "functions" :height 0.8 :face 'all-the-icons-red))
          (Constructor . ,(all-the-icons-material "functions" :height 0.8 :face 'all-the-icons-red))
          (Field . ,(all-the-icons-material "functions" :height 0.8 :face 'all-the-icons-red))
          (Variable . ,(all-the-icons-material "adjust" :height 0.8 :face 'all-the-icons-blue))
          (Class . ,(all-the-icons-material "class" :height 0.8 :face 'all-the-icons-red))
          (Interface . ,(all-the-icons-material "settings_input_component" :height 0.8 :face 'all-the-icons-red))
          (Module . ,(all-the-icons-material "view_module" :height 0.8 :face 'all-the-icons-red))
          (Property . ,(all-the-icons-material "settings" :height 0.8 :face 'all-the-icons-red))
          (Unit . ,(all-the-icons-material "straighten" :height 0.8 :face 'all-the-icons-red))
          (Value . ,(all-the-icons-material "filter_1" :height 0.8 :face 'all-the-icons-red))
          (Enum . ,(all-the-icons-material "plus_one" :height 0.8 :face 'all-the-icons-red))
          (Keyword . ,(all-the-icons-material "filter_center_focus" :height 0.8 :face 'all-the-icons-red))
          (Snippet . ,(all-the-icons-material "short_text" :height 0.8 :face 'all-the-icons-red))
          (Color . ,(all-the-icons-material "color_lens" :height 0.8 :face 'all-the-icons-red))
          (File . ,(all-the-icons-material "insert_drive_file" :height 0.8 :face 'all-the-icons-red))
          (Reference . ,(all-the-icons-material "collections_bookmark" :height 0.8 :face 'all-the-icons-red))
          (Folder . ,(all-the-icons-material "folder" :height 0.8 :face 'all-the-icons-red))
          (EnumMember . ,(all-the-icons-material "people" :height 0.8 :face 'all-the-icons-red))
          (Constant . ,(all-the-icons-material "pause_circle_filled" :height 0.8 :face 'all-the-icons-red))
          (Struct . ,(all-the-icons-material "streetview" :height 0.8 :face 'all-the-icons-red))
          (Event . ,(all-the-icons-material "event" :height 0.8 :face 'all-the-icons-red))
          (Operator . ,(all-the-icons-material "control_point" :height 0.8 :face 'all-the-icons-red))
          (TypeParameter . ,(all-the-icons-material "class" :height 0.8 :face 'all-the-icons-red))
          ;; (Template   . ,(company-box-icons-image "Template.png"))))
          (Yasnippet . ,(all-the-icons-material "short_text" :height 0.8 :face 'all-the-icons-green))
          (ElispFunction . ,(all-the-icons-material "functions" :height 0.8 :face 'all-the-icons-red))
          (ElispVariable . ,(all-the-icons-material "check_circle" :height 0.8 :face 'all-the-icons-blue))
          (ElispFeature . ,(all-the-icons-material "stars" :height 0.8 :face 'all-the-icons-orange))
          (ElispFace . ,(all-the-icons-material "format_paint" :height 0.8 :face 'all-the-icons-pink)))
        company-box-icons-alist 'company-box-icons-all-the-icons)
#+end_src
** Eldoc
#+begin_src emacs-lisp
  (diminish 'eldoc-mode)
  (setf eldoc-idle-delay 0)
#+end_src
** Language Server Support (LSP)
*** Performance
These variables are reccomended by =lsp-mode= to increase performance.
#+begin_src emacs-lisp
  (setf read-process-output-max (* 1024 1024))
#+end_src
*** LSP-Mode
#+begin_src emacs-lisp
  (pkg lsp-mode)
  (setf lsp-eldoc-enable-hover nil
        lsp-signature-render-documentation nil)
  (add-hook 'lsp-mode-hook 'evil-normal-state)
  (evil-define-key 'normal lsp-mode-map
    (kbd "<leader>=") #'lsp-format-buffer
    (kbd "<leader>gd") #'lsp-find-definition
    (kbd "<leader>gD") #'lsp-find-declaration
    (kbd "<leader>gr") #'lsp-find-references
    (kbd "<leader>gi") #'lsp-find-implementation
    (kbd "<leader>gt") #'lsp-find-type-definition
    ;; (kbd "<leader>gh") #'hierarchy
    (kbd "<leader>ga") #'xref-find-apropos
    (kbd "<leader>o") #'lsp-organize-imports
    (kbd "<leader>r") #'lsp-rename
    (kbd "<leader>te") (interactive-toggle lsp-eldoc-enable-hover)
    (kbd "<leader>a") #'lsp-execute-code-action
    (kbd "K") #'lsp-ui-doc-show
    (kbd "gK") #'lsp-describe-thing-at-point)
#+end_src
*** Prettify
#+begin_src emacs-lisp
  (pkg lsp-ui)
  (setf lsp-ui-doc-enable t
        lsp-ui-doc-delay most-positive-fixnum
        lsp-ui-doc-position 'top
        lsp-ui-sideline-show-hover t
        lsp-ui-sideline-show-symbol t
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-sideline-show-code-actions t)
#+end_src
** Completions history
#+begin_src emacs-lisp
  (pkg prescient :require t)
  (prescient-persist-mode)
  (pkg selectrum-prescient :require t)
  (selectrum-prescient-mode)
  (pkg company-prescient :require t)
  (company-prescient-mode)
#+end_src
** Consult
#+begin_src emacs-lisp
  (pkg consult)
  (pkg consult-flycheck)
  (pkg consult-projectile)
  (evil-collection-consult-setup)

  (evil-define-key 'normal flycheck-mode-map
    (kbd "<leader>e") #'consult-flycheck)
  (evil-define-key 'normal 'global
    (kbd "gb") #'consult-buffer
    (kbd "g'") #'evil-collection-consult-mark
    (kbd "<global-leader>l") #'consult-line
    (kbd "<global-leader>L") #'consult-line-multi
    (kbd "<global-leader>i") #'consult-imenu
    (kbd "<global-leader>I") #'consult-imenu-multi
    (kbd "<global-leader>P") #'consult-projectile)
#+end_src
** Embark
#+begin_src emacs-lisp
  (pkg embark)
  (pkg embark-consult)
  (evil-define-key '(normal insert) 'global
    (kbd "<global-leader>e") #'embark-act
    (kbd "<global-leader>E") #'embark-dwim)
  (after-load consult (require 'embark-consult))
#+end_src
* File Management
** File Tree
#+begin_src emacs-lisp
  (pkg treemacs)
  (pkg treemacs-evil)
  (pkg treemacs-all-the-icons)
  (pkg treemacs-projectile)
  (pkg treemacs-icons-dired)
  (pkg treemacs-magit)
  (evil-define-key 'normal 'global
    (kbd "gt") #'treemacs)
  (after-load treemacs
    (require 'treemacs-evil)
    (require 'treemacs-all-the-icons)
    (require 'treemacs-projectile)
    (require 'treemacs-icons-dired)
    (require 'treemacs-magit)
    (treemacs-load-theme 'all-the-icons))
#+end_src
** Projects
#+begin_src emacs-lisp
  (pkg projectile :require t)
  (projectile-mode)
  (setf compilation-scroll-output t)
  (evil-define-key 'normal 'global
    (kbd "<global-leader>pd") #'projectile-edit-dir-locals
    (kbd "<global-leader>pDp") (evil-define-command add-dir-locals-project-commands ()
                                 (insert "((nil . ((projectile-project-run-cmd . \"\")\n				 (projectile-project-configure-cmd . \"\") \n				 (projectile-project-compilation-cmd . \"\"))))"))

    (kbd "<global-leader>pf") #'projectile-find-file
    (kbd "<global-leader>pF") #'projectile-find-file-in-known-projects
    (kbd "<global-leader>ps") #'projectile-switch-project)
  (evil-define-key '(insert normal) projectile-mode-map
    (kbd "<f5>") #'projectile-run-project
    (kbd "<f6>") #'projectile-compile-project
    (kbd "<f7>") #'projectile-configure-project)
  (dolist (map evil-collection-compile-maps)
    (evil-define-key 'normal map
      (kbd "q") (interactive-chain #'kill-compilation #'quit-window)))
  (setf projectile-project-search-path '("~/code/"))
#+end_src
* Flycheck
#+begin_src emacs-lisp
  (pkg flycheck :require t)
  (hook 'emacs-lisp-mode-hook (flycheck-mode -1))
  (evil-declare-not-repeat #'flycheck-next-error)
  (evil-declare-not-repeat #'flycheck-previous-error)
  (evil-define-key 'normal flycheck-mode-map
    (kbd "<leader>E") #'list-flycheck-errors)
  (global-flycheck-mode)
#+end_src
* Magit
#+begin_src emacs-lisp
  (pkg magit)
  (evil-define-key 'normal 'global
    (kbd "<global-leader>m") #'magit)
  (evil-define-key '(visual normal) magit-mode-map
    (kbd "M-h") #'magit-section-up
    (kbd "M-j") #'magit-section-forward-sibling
    (kbd "M-k") #'magit-section-backward-sibling
    (kbd "C-j") nil
    (kbd "C-k") nil
    (kbd "\\") nil
    (kbd "SPC") nil)
  (evil-define-key nil magit-mode-map
    (kbd "SPC") nil)
#+end_src
* Tree-Sitter
#+begin_src emacs-lisp
  (pkg tree-sitter-langs :require t)
  (pkg tree-sitter :require t)
  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)

  (pkg tree-edit)
  (pkg evil-tree-edit)
#+end_src  

* Spellcheck
** Flyspell
#+begin_src emacs-lisp
  (pkg flyspell :require t)
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
  (add-hook 'text-mode-hook #'flyspell-mode)
  (defvar dict "en_GB"
    "Dictionary to use.")
  (setf flyspell-issue-message-flag nil
        ispell-local-dictionary "dict"
        ispell-local-dictionary-alist
        `(("dict" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" ,dict) nil utf-8)))
  (cond
   ((executable-find "hunspell")
    (setf ispell-program-name "hunspell")
    (when (boundp 'ispell-hunspell-dictionary-alist)
      (setf ispell-hunspell-dictionary-alist ispell-local-dictionary-alist)))
   ((executable-find "aspell")
    (setf ispell-program-name "aspell"
          ispell-extra-args `("--sug-mode=ultra" ,(concat "--lang=" dict)
                              "--run-together" "--run-together-limit=16"))))
  (evil-define-key 'normal flyspell-mode-map
    (kbd "[s") #'evil-prev-flyspell-error
    (kbd "]s") #'evil-next-flyspell-error)
#+end_src
** Grammarly
#+begin_src emacs-lisp
  ;; todo, maybe re-write this myself
  ;; (pkg flycheck-grammarly)
#+end_src

* Allow things to be deferred to the end of the file through config feature.
#+begin_src emacs-lisp
  (provide 'config)
#+end_src
